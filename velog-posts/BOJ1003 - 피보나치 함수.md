<h5 id="들어가며">들어가며</h5>
<p>1, 1, 2, 3, 5, 8, 13,...</p>
<h2 id="👿-문제">👿 문제</h2>
<p><a href="https://www.acmicpc.net/problem/1003">백준1003 - 피보나치 함수</a>
<img alt="" src="https://velog.velcdn.com/images/edocnuyh/post/6f172806-fe30-447a-bc9b-123fbeb71b74/image.png" /></p>
<br />


<h2 id="🧐-생각">🧐 생각</h2>
<p>각 $n$마다 찍히는 0, 1의 개수를 도표로 나타내 보았다</p>
<table>
<thead>
<tr>
<th>$n$</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>0개수</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>5</td>
<td>8</td>
</tr>
<tr>
<td>1개수</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>5</td>
<td>8</td>
<td>13</td>
</tr>
</tbody></table>
<p>0개수, 1개수 또한 시작점이 다른 피보나치 수열처럼 보인다. 따라서 하나의 피보나치 수열(배열)을 구하고, 인덱스 값을 다르게 주어서 0, 1에 대한 개수를 파악하면 되겠다고 생각했다.
물론 이렇게 푼다면, <code>n=0</code> 혹은 <code>n=1</code>인 경우에 대한 특별한 처리가 필요할 것이라고 생각했다.</p>
<br />

<h2 id="🐳-첫-시도">🐳 첫 시도</h2>
<pre><code class="language-java">public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        int[] nList = new int[T]; // 테스트할 N들을 미리 배열에 담아둠
        for (int i = 0; i &lt; T; i++) {
            nList[i] = sc.nextInt();
        }

        int max = Arrays.stream(nList).max().getAsInt();
        int[] counts = countFibo(max); // N들 중 가장 큰 값으로 피보나치수열(배열)을 구한다.

        for (int i = 0; i &lt; nList.length; i++) {
            search(counts, nList[i]); // n값에 맞는 정답을 출력한다.
        }

    }

    static int[] countFibo(int n) {
        int[] countArr = new int[n+1];
        countArr[0] = 1;
        countArr[1] = 1;
        for (int i = 2; i &lt; n+1; i++) {
            countArr[i] = countArr[i-2] + countArr[i-1];
        }
        return countArr;
    }

    static void search(int[] arr, int target) {
        if (target == 0) {
            System.out.println(&quot;1 0&quot;);
        } else if (target == 1) {
            System.out.println(&quot;0 1&quot;);
        } else {
            System.out.println(arr[target - 2] + &quot; &quot; + arr[target-1]);
        }
    }
}</code></pre>
<p>생각했던건 
<code>int[] countArr = {1,1,2,3,5,...,};</code>
이런식으로 만들고,
n이 0,1인 경우는 따로 처리하되 n이 2이상인 경우에 0의 개수는 <code>countArr[n-2]</code>, 1의 개수는 <code>count[n-1]</code>로 표현할 수 있을 것이라고 생각했다.</p>
<p>그런데 여기서 고려못했던 사항은 
nList 중 max값이 0인 경우였다.</p>
<p>예시로 </p>
<pre><code>// T = 1, N = 0
1
0</code></pre><p>을 입력하는 경우 <code>countFibo(int n)</code>함수에서 countArr의 길이를 n+1 즉 1로 선언하는데, <code>countArr[1] = 1;</code>로 값을 넣으려고 하여 <code>ArrayIndexOutOfBounds</code>에러가 났다.
<img alt="" src="https://velog.velcdn.com/images/edocnuyh/post/bd621c03-bbed-42c3-9955-0675eaff6bdd/image.png" /></p>
<br />



<h2 id="📌-두번째-시도">📌 두번째 시도</h2>
<p>위 오류포인트를 수정하기 위해 <code>countFibo</code>함수를 약간 수정했다.</p>
<pre><code class="language-java">public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        int[] nList = new int[T];
        for (int i = 0; i &lt; T; i++) {
            nList[i] = sc.nextInt();
        }

        int max = Arrays.stream(nList).max().getAsInt();
        int[] counts = countFibo(max);

        for (int i = 0; i &lt; nList.length; i++) {
            search(counts, nList[i]);
        }

    }

    static int[] countFibo(int n) {
        int[] countArr = new int[n+1];
        countArr[0] = 1;
        for (int i = 1; i &lt; n+1; i++) {
            if (i == 1) { // n = 0인 경우를 위한 조건처리
                countArr[i] = 1;
                continue;
            }
            countArr[i] = countArr[i-2] + countArr[i-1];
        }
        return countArr;
    }

    static void search(int[] arr, int target) {
        if (target == 0) {
            System.out.println(&quot;1 0&quot;);
        } else if (target == 1) {
            System.out.println(&quot;0 1&quot;);
        } else {
            System.out.println(arr[target - 2] + &quot; &quot; + arr[target-1]);
        }
    }
}</code></pre>
<p>이렇게 코드를 제출했을 때, 다행히 <strong>통과</strong>할 수 있었다.</p>
<p>그런데, 개인적으로 코드를 보았을 때 너무 _엣지케이스_를 많이 처리하고 있지 않나 생각이 들어서 다른분들의 풀이를 참고해 보았다.</p>
<br />

<h2 id="😖-다른-방법은-없을까">😖 다른 방법은 없을까?</h2>
<h3 id="1-0개수-1개수-배열-따로-선언하기">1. 0개수, 1개수 배열 따로 선언하기</h3>
<p>이 부분은 오늘 발표세션에서 발표하신 분의 풀이를 참고해 보았다.</p>
<pre><code class="language-java">public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        int[] nList = new int[T];
        for (int i = 0; i &lt; T; i++) {
            nList[i] = sc.nextInt();
        }

        int max = Arrays.stream(nList).max().getAsInt();
        int[] count_zero = new int[max+1];
        int[] count_one = new int[max+2];

        count_zero[0] = 1;
        count_one[1] = 1;
        for (int i = 2; i &lt; max + 1; i++) {
            count_zero[i] = count_zero[i-2] + count_zero[i-1];
            count_one[i] = count_one[i-2] + count_one[i-1];
        }

        for (int i = 0; i &lt; T; i++) {
            System.out.println(count_zero[nList[i]] + &quot; &quot; + count_one[nList[i]]);
        }
    }
}</code></pre>
<p>나는 0개수나 1개수 배열을 하나로 퉁칠 수 있을거라고 판단해서 하나로 퉁쳐서 풀이했지만, 위 풀이법은 각각 따로 선언하고 각각 따로 개수들을 구해줘서 좀 더 코드를 볼 때 명확하게 이해가 가능하다. 또한, 내가 풀었던 것만큼 엣지케이스를 조건절로 처리하는 경우가 많지 않다. 
아, 그리고 <code>ArrayIndexOutOfBounds</code>에러에 대한 방비책으로 <code>count_one</code>배열의 크기는 $max+2$로 잡아줘야 한다.</p>
<h3 id="2-이차배열-선언하기">2. 이차배열 선언하기</h3>
<p>이 풀이법은 백준 채점 현황에 있는 다른분들의 풀이를 참고해 보았다.</p>
<pre><code class="language-java">public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();

        int[][] counts = new int[41][2];

        counts[0] = new int[]{1,0};
        counts[1] = new int[]{0,1};

        for (int i = 2; i &lt; 41; i++) {
            counts[i][0] = counts[i-2][0] + counts[i-1][0];
            counts[i][1] = counts[i-2][1] + counts[i-1][1];
        }

        for (int i = 0; i &lt; T; i++) {
            int N = sc.nextInt();
            System.out.println(counts[N][0] + &quot; &quot; + counts[N][1]);
        }
    }
}</code></pre>
<p>$n$이 40 이하의 자연수라는 조건이 있었으므로, 가능한 n에 대한 0, 1의 개수를 이차배열로 미리 다 담아두고 해당하는 값에 대해 간단하게 출력하는 방식이다. 이 경우는 미리 담아두므로 내가 겪었던 <code>ArrayIndexOutOfBounds</code>에러에 대한 방비를 하지 않아도 된다.</p>
<br />


<h2 id="마치며">마치며</h2>
<ul>
<li>문제를 푸는 여러가지 방식이 있지만, 각각 걸리는 시간의 차이는 그다지 크지 않았다. (내가 해본 것에 한해서)
<img alt="" src="https://velog.velcdn.com/images/edocnuyh/post/3d0b0ea8-fb15-4604-96e1-6f1efa2bcf59/image.png" /></li>
<li>코드가 가장 깔끔해 보이는 것은 <strong>이차배열</strong>로 풀이한 방식인 것 같다. 그렇지만 모든 N에 대한 값을 미리 구해둘 필요가 있을까? 하는 생각이 든다</li>
<li>나의 첫 풀이도 일차배열 하나만 이용하기 때문에 그리 나쁘지 않은 시도였다고 생각한다!! (뭐가 되었든 정답이니까..)</li>
</ul>